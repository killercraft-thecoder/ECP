{"entries":[{"timestamp":1752783386584,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":50,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":66,"length1":54,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":173,"length1":64,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":202,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"server.ts","value":"const ISERVER = game.ask(\"Server?\")\nconst mySerial = control.deviceSerialNumber()\nradio.setGroup(1)\nlet DataMappings: any = { \"ME\": \"WAIT\", \"TEST\": \"TRUE\" }\n\nif (ISERVER) {\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) {\n            console.log(\"Invalid packet received: \" + packet)\n            return\n        }\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString() || dest == \"BCAST\") {\n            if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                radio.sendString(`${mySerial}|${src}|ACK|${msgID}|delivered`)\n                console.log(`✅ ACK sent to ${src} for msgID ${msgID}`)\n            } else if (type == \"PING\") {\n                let response = DataMappings[payload] || \"UNKNOWN\"\n                radio.sendString(`${mySerial}|${src}|PONG|${msgID}|${response}`)\n                console.log(`🏓 PONG sent to ${src}: ${response}`)\n            } else if (type == \"ACK\") {\n                console.log(`🔔 ACK received from ${src} for msgID ${msgID}`)\n            } else {\n                console.log(\"⚠️ Unknown type: \" + type)\n            }\n        }\n    })\n}"},{"type":"added","filename":"client.ts","value":"namespace Client {\n    let msgCounter = 0\n\n    function sendMessage(dest: string, payload: string) {\n        let msgID = \"msg\" + msgCounter++\n        let packet = `${mySerial}|${dest}|MSG|${msgID}|${payload}`\n        radio.sendString(packet)\n        console.log(`🚀 Sent MSG to ${dest}: ${payload} (ID: ${msgID})`)\n    }\n\n    function sendPing(dest: string, query: string) {\n        let msgID = \"ping\" + msgCounter++\n        let packet = `${mySerial}|${dest}|PING|${msgID}|${query}`\n        radio.sendString(packet)\n        console.log(`🔍 Sent PING to ${dest}: ${query} (ID: ${msgID})`)\n    }\n\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parts[0]\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"ACK\") {\n                console.log(`✅ ACK received from ${src} for msgID ${msgID}`)\n            } else if (type == \"PONG\") {\n                console.log(`🏓 PONG from ${src}: ${payload}`)\n            } else if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                // Optionally ACK messages too\n                let ackPacket = `${mySerial}|${src}|ACK|${msgID}|received`\n                radio.sendString(ackPacket)\n            } else {\n                console.log(\"⚠️ Unknown type received: \" + type)\n            }\n        }\n    })\n\n    // 🔘 Try sending a test message or ping!\n    sendMessage(\"BCAST\", \"Hello from client!\")\n    sendPing(\"BCAST\", \"ME\")\n}"}]},{"timestamp":1752783964048,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":249,"length1":38,"diffs":[[1,"        \"client.ts\"\n"]]}]},{"type":"edited","filename":"client.ts","patch":[{"start1":19,"length1":72,"diffs":[[1,""]]},{"start1":42,"length1":259,"diffs":[[1,""]]},{"start1":43,"length1":741,"diffs":[[1,"    function sendMessage(dest: string, payload: string) {\n"]]},{"start1":322,"length1":79,"diffs":[[1,"    function sendPing(dest: string, query: string) {\n"]]},{"start1":588,"length1":113,"diffs":[[1,""]]},{"start1":1127,"length1":307,"diffs":[[1,""]]},{"start1":1233,"length1":0,"diffs":[[1,"                // Optionally ACK messages too\n"]]},{"start1":1517,"length1":172,"diffs":[[1,"    // 🔘 Try sending a test message or ping!\n    sendMessage(\"BCAST\", \"Hello from client!\")\n    sendPing(\"BCAST\", \"ME\")\n"]]}]},{"type":"added","filename":"aes.ts","value":"// Add your code here\nnamespace AES {\n    const sbox: number[] = [\n        // A small sample substitution box — extend or randomize as needed!\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76\n    ]\n    const sbox2 = sbox.slice(0);\n    sbox2.reverse(); \n    function subBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function usubBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox2[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function shiftRows(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let shiftedIndex = (i + (i % 4)) % buffer.length\n            output.setUint8(i, buffer.getUint8(shiftedIndex))\n        }\n        return output\n    }\n\n    function mixColumns(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, ((val << 1) ^ val ^ 0x1b) & 0xFF) // Basic XOR mix\n        }\n        return output\n    }\n\n    function addRoundKey(buffer: Buffer, key: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            output.setUint8(i, buffer.getUint8(i) ^ key.getUint8(i % key.length))\n        }\n        return output\n    }\n\n    export function encrypt(input: Buffer, key: Buffer): string {\n        let state = input\n\n        // 📘 AES-like stages\n        state = subBytes(state)\n        state = shiftRows(state)\n        state = mixColumns(state)\n        state = addRoundKey(state, key)\n\n        return state.toBase64()\n    }\n\n    export function decrypt(encoded: string, key: Buffer): Buffer {\n        let state = Buffer.fromBase64(encoded)\n\n        // 🔄 Reverse order for decryption\n        state = addRoundKey(state, key)\n        state = mixColumns(state)\n        state = shiftRows(state)\n        state = usubBytes(state) // reverse S-Box would go here if needed\n\n        return state\n    }\n}"}]},{"timestamp":1752784553533,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":50,"length1":551,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":270,"length1":53,"diffs":[[1,"        \"aes.ts\"\n"]]}]},{"type":"edited","filename":"aes.ts","patch":[{"start1":260,"length1":317,"diffs":[[1,"    const sbox2 = sbox.slice(0);\n    sbox2.reverse(); \n"]]}]},{"type":"added","filename":"dh.ts","value":"namespace DH {\n    const primes = [23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    const P = primes[randint(0,primes.length-1)] // Prime modulus — small for demo\n    const G = 5  // Base\n\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n\n    let ISERVER = false\n    let sharedKey: number = -1\n    let privateKey: number\n    let publicKey: number\n\n    function generateKeys(): void {\n        privateKey = Math.randomRange(2, P - 2)\n        publicKey = Math.pow(G, privateKey) % P\n    }\n\n    function computeSharedKey(peerPublicKey: number): void {\n        sharedKey = Math.pow(peerPublicKey, privateKey) % P\n        console.log(`🔑 Shared key established: ${sharedKey}`)\n    }\n\n    // 🔁 Message handler\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"DH\") {\n                // Received public key from peer\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n\n                // If we're server, send our public key back\n                if (ISERVER) {\n                    let ackPacket = `${mySerial}|${src}|DHACK|${msgID}|${publicKey}`\n                    radio.sendString(ackPacket)\n                    console.log(`📡 Sent DHACK with server public key`)\n                }\n            } else if (type == \"DHACK\") {\n                // Client receives server's public key\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n            }\n        }\n    })\n\n    export function startHandshake(isServer: boolean): void {\n        ISERVER = isServer\n        generateKeys()\n        console.log(`🧬 Starting DH with public key ${publicKey}`)\n\n        if (!ISERVER) {\n            // Clients initiate handshake\n            let msgID = \"dh\" + control.deviceSerialNumber()\n            let packet = `${mySerial}|BCAST|DH|${msgID}|${publicKey}`\n            radio.sendString(packet)\n            console.log(`🚀 Client sent DH packet`)\n        }\n    }\n\n    export function getSharedKey(): number {\n        return sharedKey\n    }\n}"},{"type":"added","filename":"wait.ts","value":"// Add your code here\n"}]},{"timestamp":1752785142148,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":50,"length1":38,"diffs":[[1,"radio.setGroup(1)\n"]]},{"start1":69,"length1":22,"diffs":[[1,"// Start the Diffie-Hellman handshake\nDH.startHandshake(ISERVER)\n"]]},{"start1":135,"length1":73,"diffs":[[1,"// Wait a moment for handshake to complete\ngame.onUpdateInterval(2000, function () {\n    let key = DH.getSharedKey()\n    if (key != -1) {\n        console.log(`🔐 Shared key established: ${key}`)\n"]]},{"start1":331,"length1":519,"diffs":[[1,"        // Optional: convert to buffer for AES\n        let keyBuffer = control.createBuffer(16)\n        keyBuffer.fill(key)\n        console.log(`🧬 Key buffer for AES: ${keyBuffer.toBase64()}`)\n    } else {\n        console.log(\"⏳ Waiting for key exchange...\")\n    }\n"]]},{"start1":600,"length1":0,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"dh.ts","patch":[{"start1":1399,"length1":32,"diffs":[[1,""]]},{"start1":1537,"length1":82,"diffs":[[1,"            } else if (type == \"DHACK\") {\n"]]}]},{"type":"edited","filename":"wait.ts","patch":[{"start1":0,"length1":1665,"diffs":[[1,"// Add your code here\n"]]}]}]},{"timestamp":1752785750650,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dh.ts","patch":[{"start1":75,"length1":85,"diffs":[[1,"    const P = primes[randint(0,primes.length-1)] // Prime modulus — small for demo\n"]]}]}]},{"timestamp":1752785827245,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":50,"length1":39,"diffs":[[1,"Wait.waitForReady().then(function() {\n"]]},{"start1":89,"length1":70,"diffs":[[1,"    radio.setGroup(1)\n\n    // Start the Diffie-Hellman handshake\n"]]},{"start1":186,"length1":26,"diffs":[[1,"    // Wait a moment for handshake to complete\n"]]},{"start1":315,"length1":68,"diffs":[[1,"        if (key != -1) {\n"]]},{"start1":402,"length1":0,"diffs":[[1,"            // Optional: convert to buffer for AES\n"]]},{"start1":612,"length1":33,"diffs":[[1,"        } else {\n"]]},{"start1":703,"length1":2,"diffs":[[1,"\n\n})\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":305,"length1":42,"diffs":[[1,"        \"wait.ts\"\n"]]}]},{"type":"edited","filename":"dh.ts","patch":[{"start1":15,"length1":147,"diffs":[[1,"    const primes = [23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    const P = //primes[randint(0,primes.length-1)] // Prime modulus — small for demo\n    const G = 5  // Base\n"]]},{"start1":186,"length1":158,"diffs":[[1,""]]},{"start1":259,"length1":23,"diffs":[[1,"    let ISERVER = false\n    let sharedKey: number = -1\n"]]},{"start1":367,"length1":86,"diffs":[[1,""]]},{"start1":368,"length1":24,"diffs":[[1,""]]},{"start1":500,"length1":96,"diffs":[[1,""]]},{"start1":507,"length1":232,"diffs":[[1,"    function computeSharedKey(peerPublicKey: number): void {\n        sharedKey = Math.pow(peerPublicKey, privateKey) % P\n        console.log(`🔑 Shared key established: ${sharedKey}`)\n"]]},{"start1":698,"length1":564,"diffs":[[1,"    // 🔁 Message handler\n"]]},{"start1":1009,"length1":106,"diffs":[[1,"        if (dest == mySerial.toString()) {\n            if (type == \"DH\") {\n                // Received public key from peer\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n"]]},{"start1":1224,"length1":462,"diffs":[[1,"                // If we're server, send our public key back\n                if (ISERVER) {\n                    let ackPacket = `${mySerial}|${src}|DHACK|${msgID}|${publicKey}`\n                    pause(100);\n                    radio.sendString(ackPacket)\n                    console.log(`📡 Sent DHACK with server public key`)\n                }\n            } else if (type == \"DHACK\" && !ISERVER) {\n                pause(100);\n                // Client receives server's public key\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n"]]},{"start1":1812,"length1":611,"diffs":[[1,""]]},{"start1":1830,"length1":26,"diffs":[[1,""]]},{"start1":1892,"length1":0,"diffs":[[1,"        ISERVER = isServer\n"]]},{"start1":1942,"length1":0,"diffs":[[1,"        console.log(`🧬 Starting DH with public key ${publicKey}`)\n"]]},{"start1":2034,"length1":39,"diffs":[[1,"            // Clients initiate handshake\n            let msgID = \"dh\" + control.deviceSerialNumber()\n            let packet = `${mySerial}|BCAST|DH|${msgID}|${publicKey}`\n            radio.sendString(packet)\n            console.log(`🚀 Client sent DH packet`)\n"]]},{"start1":2388,"length1":85,"diffs":[[1,""]]}]},{"type":"added","filename":"disbruted.ts","value":"namespace Resources {\n    let handlers: ((receivedString: string) => void)[] = []\n    export function onReceivedString(cb: (receivedString: string) => void) {\n       handlers.push(cb)\n    }\n    radio.onReceivedString(function(str:string) {\n        handlers.forEach((a) => a(str))\n    })\n}"}]},{"timestamp":1752786442785,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"dh.ts","patch":[{"start1":1619,"length1":52,"diffs":[[1,"    radio.onReceivedString(function (packet: string) {\n"]]}]}]},{"timestamp":1752786444101,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"server.ts","patch":[{"start1":173,"length1":59,"diffs":[[1,"    radio.onReceivedString(function (packet: string) {\n"]]}]},{"type":"edited","filename":"client.ts","patch":[{"start1":1748,"length1":59,"diffs":[[1,"    radio.onReceivedString(function (packet: string) {\n"]]}]},{"type":"edited","filename":"dh.ts","patch":[{"start1":1619,"length1":59,"diffs":[[1,"    rR.onReceivedString(function (packet: string) {\n"]]}]},{"type":"edited","filename":"wait.ts","patch":[{"start1":1372,"length1":56,"diffs":[[1,"    radio.onReceivedString(function (msg: string) {\n"]]}]},{"type":"edited","filename":"disbruted.ts","patch":[{"start1":22,"length1":68,"diffs":[[1,"    let handlers: ((receivedString: string) => void)[] = []\n"]]},{"start1":159,"length1":26,"diffs":[[1,"       handlers.push(cb)\n"]]},{"start1":190,"length1":356,"diffs":[[1,"    radio.onReceivedString(function(str:string) {\n        handlers.forEach((a) => a(str))\n"]]}]}]},{"timestamp":1752787045766,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"disbruted.ts","patch":[{"start1":167,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1752787048818,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":305,"length1":18,"diffs":[[1,"        \"wait.ts\",\n        \"disbruted.ts\"\n"]]}]},{"type":"edited","filename":"server.ts","patch":[{"start1":158,"length1":238,"diffs":[[1,"if (ISERVER) {\n    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n"]]},{"start1":394,"length1":0,"diffs":[[1,"        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n"]]},{"start1":1332,"length1":2419,"diffs":[[1,"    })\n}"]]}]},{"type":"edited","filename":"client.ts","patch":[{"start1":1000,"length1":57,"diffs":[[1,"    let pendingPromises: Promise<Response>[] = []\n"]]},{"start1":1748,"length1":0,"diffs":[[1,"    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parts[0]\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"ACK\") {\n                console.log(`✅ ACK received from ${src} for msgID ${msgID}`)\n            } else if (type == \"PONG\") {\n                console.log(`🏓 PONG from ${src}: ${payload}`)\n                for (let i = 0; i < pendingPromises.length; i++) {\n                    if (pendingPromises[i].id == msgID) {\n                        pendingPromises[i].resolve(payload)\n                        pendingPromises.removeAt(i)\n                        break\n                    }\n                }\n            } else if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                let ackPacket = `${mySerial}|${src}|ACK|${msgID}|received`\n                radio.sendString(ackPacket)\n            } else {\n                console.log(\"⚠️ Unknown type received: \" + type)\n            }\n        }\n    })\n\n"]]}]},{"type":"edited","filename":"dh.ts","patch":[{"start1":198,"length1":143,"diffs":[[1,"    const P = primes[Math.randomRange(0, primes.length)]\n    const G = generators[Math.randomRange(0, generators.length)]\n"]]},{"start1":444,"length1":140,"diffs":[[1,"    let publicKey: number\n    let peerSerial = -1\n    let peerPublicKey = -1\n    let handshakeCompleted = false\n"]]},{"start1":581,"length1":43,"diffs":[[1,"    function generateKeys(): void {\n"]]},{"start1":845,"length1":62,"diffs":[[1,"    function computeSharedKey(peerKey: number): void {\n"]]},{"start1":1078,"length1":42,"diffs":[[1,"    function broadcastDH(): void {\n"]]},{"start1":1592,"length1":0,"diffs":[[1,"    // 📨 On radio receive\n    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest != mySerial.toString() && dest != \"BCAST\") return\n        if (handshakeCompleted) return\n\n        if (type == \"DH\") {\n            let values = payload.split(\",\")\n            if (values.length != 3) return\n\n            let incomingP = parseInt(values[0])\n            let incomingG = parseInt(values[1])\n            let peerKey = parseInt(values[2])\n\n            peerSerial = src\n            peerPublicKey = peerKey\n\n            if (incomingP != P || incomingG != G) {\n                console.log(`⚠️ DH param mismatch. Ignored.`)\n                return\n            }\n\n            computeSharedKey(peerPublicKey)\n\n            // Server replies back to client\n            if (ISERVER) {\n                let replyID = \"dhack_\" + Math.randomRange(1000, 9999)\n                let reply = `${mySerial}|${src}|DHACK|${replyID}|${publicKey}`\n                pause(100)\n                radio.sendString(reply)\n                console.log(`📡 Server replied with DHACK`)\n            }\n        } else if (type == \"DHACK\" && !ISERVER) {\n            let peerKey = parseInt(payload)\n            peerSerial = src\n            peerPublicKey = peerKey\n            computeSharedKey(peerPublicKey)\n        }\n    })\n\n"]]}]},{"type":"edited","filename":"wait.ts","patch":[{"start1":952,"length1":51,"diffs":[[1,"    let pending: Promise<Connection>[] = []\n"]]},{"start1":1371,"length1":0,"diffs":[[1,"\n    Resources.onReceivedString(function (msg: string) {\n        if (msg.substr(0,6) == \"READY|\") {\n            console.log(\"📲 Another device is ready!\")\n            if (pending.length > 0) {\n                pending[0].resolve()\n                pending.removeAt(0)\n            }\n        }\n    })\n"]]}]},{"type":"removed","filename":"disbruted.ts","value":"namespace Resources {\n    export let Handlers: ((receivedString: string) => void)[] = []\n\n    export function onReceivedString(cb: (receivedString: string) => void) {\n        \n        Handlers.push(cb)\n    }\n\n    radio.onReceivedString(function (str: string) {\n        // 🚧 Confirm 'handlers' is ready before using\n        if (!Handlers || Handlers.length === 0) {\n            console.log(\"⚠️ No handlers registered yet\")\n            return\n        }\n\n        Handlers.forEach((handler) => {\n            if (typeof handler === \"function\") handler(str)\n        })\n    })\n}"}]},{"timestamp":1752787647348,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":305,"length1":49,"diffs":[[1,"        \"wait.ts\"\n"]]}]},{"type":"edited","filename":"server.ts","patch":[{"start1":377,"length1":42,"diffs":[[1,"    if (ISERVER) {\n        if (parts.length < 5) {\n            console.log(\"Invalid packet received: \" + packet)\n            return\n        }\n"]]},{"start1":2753,"length1":0,"diffs":[[1,"\n        let src = parts[0]\n    \n\n"]]}]},{"type":"edited","filename":"dh.ts","patch":[{"start1":673,"length1":102,"diffs":[[1,"        privateKey = Math.randomRange(2, P - 2)\n        publicKey = Math.pow(G, privateKey) % P\n"]]}]},{"type":"added","filename":"simplekeyexhange.ts","value":"namespace SharedKey {\n    export let key = -1\n    let mySerial = control.deviceSerialNumber()\n    let initialized = false\n\n    export function broadcastKey(globalKey?: number): void {\n        if (isSet()) return\n        key = globalKey || randint(0,65535)\n        radio.sendString(`SHAREDKEY|${key}`)\n        console.log(`📡 Shared key broadcast: ${key}`)\n    }\n\n    export function isSet(): boolean {\n        return key != -1\n    }\n\n    export function getKey(): number {\n        return key\n    }\n\n    // One-time setup to listen for key\n    export function initReceiver(): void {\n        if (initialized) return\n        initialized = true\n\n        radio.onReceivedString(function (msg: string) {\n            if (msg.substr(0,10) == \"SHAREDKEY|\") {\n                let parts = msg.split(\"|\")\n                if (parts.length == 2) {\n                    key = parseInt(parts[1])\n                    console.log(`🔐 Global key received: ${key}`)\n                }\n            }\n        })\n    }\n}"}]},{"timestamp":1752788205797,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":160,"length1":29,"diffs":[[1,"    DH.startHandshake(ISERVER)\n\n    let connected = false\n    game.onUpdateInterval(2000, function () {\n        let key = DH.getSharedKey()\n        if (!connected && key != -1) {\n            connected = true\n            console.log(`🔐 Shared key established: ${key}`)\n\n            let keyBuffer = control.createBuffer(16)\n            keyBuffer.fill(key)\n            console.log(`🧬 Key buffer for AES: ${keyBuffer.toBase64()}`)\n        } else if (!connected) {\n            console.log(\"⏳ Waiting for key exchange...\")\n        }\n    })\n"]]}]},{"type":"edited","filename":"server.ts","patch":[{"start1":210,"length1":274,"diffs":[[1,""]]}]},{"type":"edited","filename":"aes.ts","patch":[{"start1":2818,"length1":224,"diffs":[[1,""]]}]},{"type":"edited","filename":"simplekeyexhange.ts","patch":[{"start1":22,"length1":25,"diffs":[[1,"    export let key = -1\n"]]},{"start1":212,"length1":344,"diffs":[[1,"        key = globalKey || randint(0,65535)\n        radio.sendString(`SHAREDKEY|${key}`)\n        console.log(`📡 Shared key broadcast: ${key}`)\n"]]},{"start1":402,"length1":26,"diffs":[[1,"        return key != -1\n"]]},{"start1":473,"length1":20,"diffs":[[1,"        return key\n"]]},{"start1":498,"length1":0,"diffs":[[1,"\n    // One-time setup to listen for key\n    export function initReceiver(): void {\n        if (initialized) return\n        initialized = true\n\n        radio.onReceivedString(function (msg: string) {\n            if (msg.substr(0,10) == \"SHAREDKEY|\") {\n                let parts = msg.split(\"|\")\n                if (parts.length == 2) {\n                    key = parseInt(parts[1])\n                    console.log(`🔐 Global key received: ${key}`)\n                }\n            }\n        })\n    }\n"]]}]}]},{"timestamp":1752788839421,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"server.ts","patch":[{"start1":210,"length1":48,"diffs":[[1,"    if (packet.substr(0, 10) == \"SHAREDKEY|\" && !SharedKey.isSet()) {\n"]]}]}]},{"timestamp":1752788851620,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":43,"diffs":[[1,"/** ECP stands For Encpyted Connection Protcal */\n// ✅ Set group early\n"]]},{"start1":90,"length1":0,"diffs":[[1,"// ✅ Wait for device readiness\n"]]},{"start1":160,"length1":43,"diffs":[[1,""]]},{"start1":189,"length1":586,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":361,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1752783386583,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"ECP\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1752785339672,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/** ECP stands For Encpyted Connection Protcal */\nradio.setGroup(1)\n\n// Start the Diffie-Hellman handshake\nDH.startHandshake(ISERVER)\n\n// Wait a moment for handshake to complete\ngame.onUpdateInterval(2000, function () {\n    let key = DH.getSharedKey()\n    if (key != -1) {\n        console.log(`🔐 Shared key established: ${key}`)\n\n        // Optional: convert to buffer for AES\n        let keyBuffer = control.createBuffer(16)\n        keyBuffer.fill(key)\n        console.log(`🧬 Key buffer for AES: ${keyBuffer.toBase64()}`)\n    } else {\n        console.log(\"⏳ Waiting for key exchange...\")\n    }\n})\n\n","README.md":" ","assets.json":"","server.ts":"const ISERVER = game.ask(\"Server?\")\nconst mySerial = control.deviceSerialNumber()\nradio.setGroup(1)\nlet DataMappings: any = { \"ME\": \"WAIT\", \"TEST\": \"TRUE\" }\n\nif (ISERVER) {\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) {\n            console.log(\"Invalid packet received: \" + packet)\n            return\n        }\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString() || dest == \"BCAST\") {\n            if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                radio.sendString(`${mySerial}|${src}|ACK|${msgID}|delivered`)\n                console.log(`✅ ACK sent to ${src} for msgID ${msgID}`)\n            } else if (type == \"PING\") {\n                let response = DataMappings[payload] || \"UNKNOWN\"\n                radio.sendString(`${mySerial}|${src}|PONG|${msgID}|${response}`)\n                console.log(`🏓 PONG sent to ${src}: ${response}`)\n            } else if (type == \"ACK\") {\n                console.log(`🔔 ACK received from ${src} for msgID ${msgID}`)\n            } else {\n                console.log(\"⚠️ Unknown type: \" + type)\n            }\n        }\n    })\n}","client.ts":"namespace Client {\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n    let msgCounter = 0\n    // Just for Neat Typing\n    export class Response { }\n    export class Promise<Response> {\n        private msgID: string\n        private resolved: boolean = false\n        private value: string = \"\"\n        private resolver: (value: string) => void = null\n\n        constructor(msgID: string) {\n            this.msgID = msgID\n        }\n\n        public then(res: (value: string) => void): void {\n            this.resolver = res\n            if (this.resolved) {\n                this.resolver(this.value)\n            }\n        }\n\n        public resolve(data: string): void {\n            if (!this.resolved) {\n                this.resolved = true\n                this.value = data\n                if (this.resolver) {\n                    this.resolver(this.value)\n                }\n            }\n        }\n\n        public get id(): string {\n            return this.msgID\n        }\n    }\n\n    let pendingPromises: Promise<Response>[] = []\n\n    function sendMessage(dest: string, payload: string): void {\n        let msgID = \"msg\" + msgCounter++\n        let packet = `${mySerial}|${dest}|MSG|${msgID}|${payload}`\n        radio.sendString(packet)\n        console.log(`🚀 Sent MSG to ${dest}: ${payload} (ID: ${msgID})`)\n    }\n\n    export function sendPing(dest: string, query: string): Promise<Response> {\n        let msgID = \"ping\" + msgCounter++\n        let packet = `${mySerial}|${dest}|PING|${msgID}|${query}`\n        radio.sendString(packet)\n        console.log(`🔍 Sent PING to ${dest}: ${query} (ID: ${msgID})`)\n\n        let promise = new Promise<Response>(msgID)\n        pendingPromises.push(promise)\n        return promise\n    }\n\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parts[0]\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"ACK\") {\n                console.log(`✅ ACK received from ${src} for msgID ${msgID}`)\n            } else if (type == \"PONG\") {\n                console.log(`🏓 PONG from ${src}: ${payload}`)\n                for (let i = 0; i < pendingPromises.length; i++) {\n                    if (pendingPromises[i].id == msgID) {\n                        pendingPromises[i].resolve(payload)\n                        pendingPromises.removeAt(i)\n                        break\n                    }\n                }\n            } else if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                let ackPacket = `${mySerial}|${src}|ACK|${msgID}|received`\n                radio.sendString(ackPacket)\n            } else {\n                console.log(\"⚠️ Unknown type received: \" + type)\n            }\n        }\n    })\n\n    // 🔘 Example usage\n    let ping = sendPing(\"BCAST\", \"ME\")\n    ping.then(function (response: string) {\n        console.log(`🔧 Ping resolved with: ${response}`)\n    })\n}","aes.ts":"// Add your code here\nnamespace AES {\n    const sbox: number[] = [\n        // A small sample substitution box — extend or randomize as needed!\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76\n    ]\n    function generateInverseSbox(original: number[]): number[] {\n        let inverse = []\n        for (let i = 0; i < 256; i++) inverse.push(0)\n        for (let i = 0; i < original.length; i++) {\n            inverse[original[i]] = i\n        }\n        return inverse\n    }\n\n    const sbox2 = generateInverseSbox(sbox)\n    function subBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function usubBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox2[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function shiftRows(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let shiftedIndex = (i + (i % 4)) % buffer.length\n            output.setUint8(i, buffer.getUint8(shiftedIndex))\n        }\n        return output\n    }\n\n    function mixColumns(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, ((val << 1) ^ val ^ 0x1b) & 0xFF) // Basic XOR mix\n        }\n        return output\n    }\n\n    function addRoundKey(buffer: Buffer, key: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            output.setUint8(i, buffer.getUint8(i) ^ key.getUint8(i % key.length))\n        }\n        return output\n    }\n\n    export function encrypt(input: Buffer, key: Buffer): string {\n        let state = input\n\n        // 📘 AES-like stages\n        state = subBytes(state)\n        state = shiftRows(state)\n        state = mixColumns(state)\n        state = addRoundKey(state, key)\n\n        return state.toBase64()\n    }\n\n    export function decrypt(encoded: string, key: Buffer): Buffer {\n        let state = Buffer.fromBase64(encoded)\n\n        // 🔄 Reverse order for decryption\n        state = addRoundKey(state, key)\n        state = mixColumns(state)\n        state = shiftRows(state)\n        state = usubBytes(state) // reverse S-Box would go here if needed\n\n        return state\n    }\n}","dh.ts":"namespace DH {\n    const primes = [23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    const P = primes[randint(0,primes.length-1)] // Prime modulus — small for demo\n    const G = 5  // Base\n\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n\n    let ISERVER = false\n    let sharedKey: number = -1\n    let privateKey: number\n    let publicKey: number\n\n    function generateKeys(): void {\n        privateKey = Math.randomRange(2, P - 2)\n        publicKey = Math.pow(G, privateKey) % P\n    }\n\n    function computeSharedKey(peerPublicKey: number): void {\n        sharedKey = Math.pow(peerPublicKey, privateKey) % P\n        console.log(`🔑 Shared key established: ${sharedKey}`)\n    }\n\n    // 🔁 Message handler\n    radio.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"DH\") {\n                // Received public key from peer\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n\n                // If we're server, send our public key back\n                if (ISERVER) {\n                    let ackPacket = `${mySerial}|${src}|DHACK|${msgID}|${publicKey}`\n                    radio.sendString(ackPacket)\n                    console.log(`📡 Sent DHACK with server public key`)\n                }\n            } else if (type == \"DHACK\") {\n                // Client receives server's public key\n                let peerKey = parseInt(payload)\n                computeSharedKey(peerKey)\n            }\n        }\n    })\n\n    export function startHandshake(isServer: boolean): void {\n        ISERVER = isServer\n        generateKeys()\n        console.log(`🧬 Starting DH with public key ${publicKey}`)\n\n        if (!ISERVER) {\n            // Clients initiate handshake\n            let msgID = \"dh\" + control.deviceSerialNumber()\n            let packet = `${mySerial}|BCAST|DH|${msgID}|${publicKey}`\n            radio.sendString(packet)\n            console.log(`🚀 Client sent DH packet`)\n        }\n    }\n\n    export function getSharedKey(): number {\n        return sharedKey\n    }\n}","wait.ts":"// Add your code here\n","pxt.json":"{\n    \"name\": \"ECP\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"server.ts\",\n        \"client.ts\",\n        \"aes.ts\",\n        \"dh.ts\",\n        \"wait.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1752787142540,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/** ECP stands For Encpyted Connection Protcal */\n// ✅ Set group early\nradio.setGroup(1)\n\n// ✅ Wait for device readiness\nWait.waitForReady().then(function () {\n    DH.startHandshake(ISERVER)\n\n    let connected = false\n    game.onUpdateInterval(2000, function () {\n        let key = DH.getSharedKey()\n        if (!connected && key != -1) {\n            connected = true\n            console.log(`🔐 Shared key established: ${key}`)\n\n            let keyBuffer = control.createBuffer(16)\n            keyBuffer.fill(key)\n            console.log(`🧬 Key buffer for AES: ${keyBuffer.toBase64()}`)\n        } else if (!connected) {\n            console.log(\"⏳ Waiting for key exchange...\")\n        }\n    })\n})","README.md":" ","assets.json":"","server.ts":"const ISERVER = game.ask(\"Server?\")\nconst mySerial = control.deviceSerialNumber()\nradio.setGroup(1)\nlet DataMappings: any = { \"ME\": \"WAIT\", \"TEST\": \"TRUE\" }\n\nif (ISERVER) {\n    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) {\n            console.log(\"Invalid packet received: \" + packet)\n            return\n        }\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString() || dest == \"BCAST\") {\n            if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                radio.sendString(`${mySerial}|${src}|ACK|${msgID}|delivered`)\n                console.log(`✅ ACK sent to ${src} for msgID ${msgID}`)\n            } else if (type == \"PING\") {\n                let response = DataMappings[payload] || \"UNKNOWN\"\n                radio.sendString(`${mySerial}|${src}|PONG|${msgID}|${response}`)\n                console.log(`🏓 PONG sent to ${src}: ${response}`)\n            } else if (type == \"ACK\") {\n                console.log(`🔔 ACK received from ${src} for msgID ${msgID}`)\n            } else {\n                console.log(\"⚠️ Unknown type: \" + type)\n            }\n        }\n    })\n}","client.ts":"namespace Client {\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n    let msgCounter = 0\n    // Just for Neat Typing\n    export class Response { }\n    export class Promise<Response> {\n        private msgID: string\n        private resolved: boolean = false\n        private value: string = \"\"\n        private resolver: (value: string) => void = null\n\n        constructor(msgID: string) {\n            this.msgID = msgID\n        }\n\n        public then(res: (value: string) => void): void {\n            this.resolver = res\n            if (this.resolved) {\n                this.resolver(this.value)\n            }\n        }\n\n        public resolve(data: string): void {\n            if (!this.resolved) {\n                this.resolved = true\n                this.value = data\n                if (this.resolver) {\n                    this.resolver(this.value)\n                }\n            }\n        }\n\n        public get id(): string {\n            return this.msgID\n        }\n    }\n\n    let pendingPromises: Promise<Response>[] = []\n\n    function sendMessage(dest: string, payload: string): void {\n        let msgID = \"msg\" + msgCounter++\n        let packet = `${mySerial}|${dest}|MSG|${msgID}|${payload}`\n        radio.sendString(packet)\n        console.log(`🚀 Sent MSG to ${dest}: ${payload} (ID: ${msgID})`)\n    }\n\n    export function sendPing(dest: string, query: string): Promise<Response> {\n        let msgID = \"ping\" + msgCounter++\n        let packet = `${mySerial}|${dest}|PING|${msgID}|${query}`\n        radio.sendString(packet)\n        console.log(`🔍 Sent PING to ${dest}: ${query} (ID: ${msgID})`)\n\n        let promise = new Promise<Response>(msgID)\n        pendingPromises.push(promise)\n        return promise\n    }\n\n    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parts[0]\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest == mySerial.toString()) {\n            if (type == \"ACK\") {\n                console.log(`✅ ACK received from ${src} for msgID ${msgID}`)\n            } else if (type == \"PONG\") {\n                console.log(`🏓 PONG from ${src}: ${payload}`)\n                for (let i = 0; i < pendingPromises.length; i++) {\n                    if (pendingPromises[i].id == msgID) {\n                        pendingPromises[i].resolve(payload)\n                        pendingPromises.removeAt(i)\n                        break\n                    }\n                }\n            } else if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                let ackPacket = `${mySerial}|${src}|ACK|${msgID}|received`\n                radio.sendString(ackPacket)\n            } else {\n                console.log(\"⚠️ Unknown type received: \" + type)\n            }\n        }\n    })\n\n    // 🔘 Example usage\n    let ping = sendPing(\"BCAST\", \"ME\")\n    ping.then(function (response: string) {\n        console.log(`🔧 Ping resolved with: ${response}`)\n    })\n}","aes.ts":"// Add your code here\nnamespace AES {\n    const sbox: number[] = [\n        // A small sample substitution box — extend or randomize as needed!\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76\n    ]\n    function generateInverseSbox(original: number[]): number[] {\n        let inverse = []\n        for (let i = 0; i < 256; i++) inverse.push(0)\n        for (let i = 0; i < original.length; i++) {\n            inverse[original[i]] = i\n        }\n        return inverse\n    }\n\n    const sbox2 = generateInverseSbox(sbox)\n    function subBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function usubBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox2[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function shiftRows(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let shiftedIndex = (i + (i % 4)) % buffer.length\n            output.setUint8(i, buffer.getUint8(shiftedIndex))\n        }\n        return output\n    }\n\n    function mixColumns(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, ((val << 1) ^ val ^ 0x1b) & 0xFF) // Basic XOR mix\n        }\n        return output\n    }\n\n    function addRoundKey(buffer: Buffer, key: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            output.setUint8(i, buffer.getUint8(i) ^ key.getUint8(i % key.length))\n        }\n        return output\n    }\n\n    export function encrypt(input: Buffer, key: Buffer): string {\n        let state = input\n\n        // 📘 AES-like stages\n        state = subBytes(state)\n        state = shiftRows(state)\n        state = mixColumns(state)\n        state = addRoundKey(state, key)\n\n        return state.toBase64()\n    }\n\n    export function decrypt(encoded: string, key: Buffer): Buffer {\n        let state = Buffer.fromBase64(encoded)\n\n        // 🔄 Reverse order for decryption\n        state = addRoundKey(state, key)\n        state = mixColumns(state)\n        state = shiftRows(state)\n        state = usubBytes(state) // reverse S-Box would go here if needed\n\n        return state\n    }\n}","dh.ts":"namespace DH {\n    // 🔢 Primes and possible generators (small and demo-safe)\n    const primes = [23, 29, 31, 37, 41, 43, 47]\n    const generators = [2, 3, 5, 7]\n\n    // 🎲 Random prime + generator\n    const P = primes[Math.randomRange(0, primes.length)]\n    const G = generators[Math.randomRange(0, generators.length)]\n\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n\n    let sharedKey = -1\n    let privateKey: number\n    let publicKey: number\n    let peerSerial = -1\n    let peerPublicKey = -1\n    let handshakeCompleted = false\n\n    // 🔑 Generate keys\n    function generateKeys(): void {\n        privateKey = Math.randomRange(2, P - 2)\n        publicKey = Math.pow(G, privateKey) % P\n        console.log(`🔧 DH params: P=${P}, G=${G}, private=${privateKey}, public=${publicKey}`)\n    }\n\n    // 🧮 Compute shared key\n    function computeSharedKey(peerKey: number): void {\n        sharedKey = Math.pow(peerKey, privateKey) % P\n        handshakeCompleted = true\n        console.log(`🔐 Shared key computed: ${sharedKey}`)\n    }\n\n    // 📡 Send DH data\n    function broadcastDH(): void {\n        let msgID = \"dh_\" + Math.randomRange(1000, 9999)\n        let packet = `${mySerial}|BCAST|DH|${msgID}|${P},${G},${publicKey}`\n        radio.sendString(packet)\n        console.log(`📤 Sent DH packet`)\n    }\n\n    // 🔁 Retry loop for client broadcast\n    function keepSendingUntilComplete(): void {\n        control.runInParallel(function () {\n            while (!handshakeCompleted) {\n                broadcastDH()\n                pause(500)\n            }\n        })\n    }\n\n    // 📨 On radio receive\n    Resources.onReceivedString(function (packet: string) {\n        let parts = packet.split(\"|\")\n        if (parts.length < 5) return\n\n        let src = parseInt(parts[0])\n        let dest = parts[1]\n        let type = parts[2]\n        let msgID = parts[3]\n        let payload = parts[4]\n\n        if (dest != mySerial.toString() && dest != \"BCAST\") return\n        if (handshakeCompleted) return\n\n        if (type == \"DH\") {\n            let values = payload.split(\",\")\n            if (values.length != 3) return\n\n            let incomingP = parseInt(values[0])\n            let incomingG = parseInt(values[1])\n            let peerKey = parseInt(values[2])\n\n            peerSerial = src\n            peerPublicKey = peerKey\n\n            if (incomingP != P || incomingG != G) {\n                console.log(`⚠️ DH param mismatch. Ignored.`)\n                return\n            }\n\n            computeSharedKey(peerPublicKey)\n\n            // Server replies back to client\n            if (ISERVER) {\n                let replyID = \"dhack_\" + Math.randomRange(1000, 9999)\n                let reply = `${mySerial}|${src}|DHACK|${replyID}|${publicKey}`\n                pause(100)\n                radio.sendString(reply)\n                console.log(`📡 Server replied with DHACK`)\n            }\n        } else if (type == \"DHACK\" && !ISERVER) {\n            let peerKey = parseInt(payload)\n            peerSerial = src\n            peerPublicKey = peerKey\n            computeSharedKey(peerPublicKey)\n        }\n    })\n\n    // 🚀 Start handshake\n    export function startHandshake(isServer: boolean): void {\n        generateKeys()\n\n        if (!ISERVER) {\n            keepSendingUntilComplete()\n        }\n    }\n\n    export function getSharedKey(): number {\n        return sharedKey\n    }\n\n    export function isComplete(): boolean {\n        return handshakeCompleted\n    }\n}","wait.ts":"namespace Wait {\n    class Connection {\n        public timestamp: number\n        constructor() {\n            this.timestamp = control.millis()\n        }\n\n        public isFresh(): boolean {\n            return control.millis() - this.timestamp < 10000\n        }\n    }\n\n    class Promise<Connection> {\n        private resolved = false\n        private conn: any = null\n        private resolver: (conn: Connection) => void = null\n        \n        constructor() {}\n\n        public then(res: (conn: Connection) => void): void {\n            this.resolver = res\n            let id = setInterval(function() {\n                if (this.resolved && this.conn) res(this.conn); clearInterval(id)\n            },100)\n        }\n\n        public resolve(): void {\n            if (!this.resolved) {\n                this.conn = new Connection()\n                this.resolved = true\n                if (this.resolver) this.resolver(this.conn)\n            }\n        }\n    }\n\n    let pending: Promise<Connection>[] = []\n\n    export function waitForReady(): Promise<Connection> {\n        let promise = new Promise<Connection>()\n        pending.push(promise)\n\n        // Broadcast our readiness so others can respond\n        let msgID = \"ready\" + Math.randomRange(1000, 9999)\n        radio.sendString(`READY|${msgID}`)\n        console.log(\"📡 Broadcasted readiness\")\n\n        return promise\n    }\n\n    Resources.onReceivedString(function (msg: string) {\n        if (msg.substr(0,6) == \"READY|\") {\n            console.log(\"📲 Another device is ready!\")\n            if (pending.length > 0) {\n                pending[0].resolve()\n                pending.removeAt(0)\n            }\n        }\n    })\n}","disbruted.ts":"namespace Resources {\n    let handlers: ((receivedString: string) => void)[] = []\n    let initialized = false\n\n    export function onReceivedString(cb: (receivedString: string) => void) {\n        if (!initialized) {\n            initialized = true\n            radio.onReceivedString(function (str: string) {\n                handlers.forEach((a) => a(str))\n            })\n        }\n\n        handlers.push(cb)\n    }\n\n\n    radio.onReceivedString(function (str: string) {\n        // 🚧 Confirm 'handlers' is ready before using\n        if (!handlers || handlers.length === 0) {\n            console.log(\"⚠️ No handlers registered yet\")\n            return\n        }\n\n        handlers.forEach((handler) => {\n            if (typeof handler === \"function\") handler(str)\n        })\n    })\n}","pxt.json":"{\n    \"name\": \"ECP\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"server.ts\",\n        \"client.ts\",\n        \"aes.ts\",\n        \"dh.ts\",\n        \"wait.ts\",\n        \"disbruted.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1752788945314,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"/** ECP stands For Encpyted Connection Protcal */\n// ✅ Set group early\nradio.setGroup(1)\n\n// ✅ Wait for device readiness\nWait.waitForReady().then(function () {\n    SharedKey.broadcastKey()\n})","README.md":" ","assets.json":"","server.ts":"const ISERVER = game.ask(\"Server?\")\nconst mySerial = control.deviceSerialNumber()\nradio.setGroup(1)\nlet DataMappings: any = { \"ME\": \"WAIT\", \"TEST\": \"TRUE\" }\n\n\nradio.onReceivedString(function (packet: string) {\n    if (packet.substr(0, 10) == \"SHAREDKEY|\") {\n        let parts = packet.split(\"|\")\n        if (parts.length == 2) {\n            SharedKey._key = parseInt(parts[1])\n            console.log(`🔐 Global key received: ${SharedKey._key}`)\n        }\n    }\n    let parts = packet.split(\"|\")\n    let src = parseInt(parts[0])\n    let dest = parts[1]\n    let type = parts[2]\n    let msgID = parts[3]\n    let payload = parts[4]\n    if (ISERVER && !(parts.length < 5)) {\n\n        if (dest == mySerial.toString() || dest == \"BCAST\") {\n            if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                radio.sendString(`${mySerial}|${src}|ACK|${msgID}|delivered`)\n                console.log(`✅ ACK sent to ${src} for msgID ${msgID}`)\n            } else if (type == \"PING\") {\n                let response = DataMappings[payload] || \"UNKNOWN\"\n                radio.sendString(`${mySerial}|${src}|PONG|${msgID}|${response}`)\n                console.log(`🏓 PONG sent to ${src}: ${response}`)\n            } else if (type == \"ACK\") {\n                console.log(`🔔 ACK received from ${src} for msgID ${msgID}`)\n            } else {\n                console.log(\"⚠️ Unknown type: \" + type)\n            }\n        }\n    }\n    if (packet.substr(0, 6) == \"READY|\") {\n        console.log(\"📲 Another device is ready!\")\n        if (Wait.pending.length > 0) {\n            Wait.pending[0].resolve()\n            Wait.pending.removeAt(0)\n        }\n    }\n    if (!(parts.length < 5)) {\n\n    if (dest != mySerial.toString() && dest != \"BCAST\") return\n    if (DH.handshakeCompleted) return\n\n    if (type == \"DH\") {\n        let values = payload.split(\",\")\n        if (values.length != 3) return\n\n        let incomingP = parseInt(values[0])\n        let incomingG = parseInt(values[1])\n        let peerKey = parseInt(values[2])\n\n        DH.peerSerial = src\n        DH.peerPublicKey = peerKey\n\n        if (incomingP != DH.P || incomingG != DH.G) {\n            console.log(`⚠️ DH param mismatch. Ignored.`)\n            return\n        }\n\n        DH.computeSharedKey(DH.peerPublicKey)\n\n        // Server replies back to client\n        if (ISERVER) {\n            let replyID = \"dhack_\" + Math.randomRange(1000, 9999)\n            let reply = `${mySerial}|${src}|DHACK|${replyID}|${DH.publicKey}`\n            pause(100)\n            radio.sendString(reply)\n            console.log(`📡 Server replied with DHACK`)\n        }\n    } else if (type == \"DHACK\" && !ISERVER) {\n        let peerKey = parseInt(payload)\n        DH.peerSerial = src\n        DH.peerPublicKey = peerKey\n        DH.computeSharedKey(DH.peerPublicKey)\n    }\n    }\n    if (!ISERVER) {\n        if (parts.length < 5) return\n        if (dest == mySerial.toString()) {\n            if (type == \"ACK\") {\n                console.log(`✅ ACK received from ${src} for msgID ${msgID}`)\n            } else if (type == \"PONG\") {\n                console.log(`🏓 PONG from ${src}: ${payload}`)\n                for (let i = 0; i < Client.pendingPromises.length; i++) {\n                    if (Client.pendingPromises[i].id == msgID) {\n                        Client.pendingPromises[i].resolve(payload)\n                        Client.pendingPromises.removeAt(i)\n                        break\n                    }\n                }\n            } else if (type == \"MSG\") {\n                console.log(`📨 Message from ${src}: ${payload}`)\n                let ackPacket = `${mySerial}|${src}|ACK|${msgID}|received`\n                radio.sendString(ackPacket)\n            } else {\n                console.log(\"⚠️ Unknown type received: \" + type)\n            }\n        }\n    }\n})\n","client.ts":"namespace Client {\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n    let msgCounter = 0\n    // Just for Neat Typing\n    export class Response { }\n    export class Promise<Response> {\n        private msgID: string\n        private resolved: boolean = false\n        private value: string = \"\"\n        private resolver: (value: string) => void = null\n\n        constructor(msgID: string) {\n            this.msgID = msgID\n        }\n\n        public then(res: (value: string) => void): void {\n            this.resolver = res\n            if (this.resolved) {\n                this.resolver(this.value)\n            }\n        }\n\n        public resolve(data: string): void {\n            if (!this.resolved) {\n                this.resolved = true\n                this.value = data\n                if (this.resolver) {\n                    this.resolver(this.value)\n                }\n            }\n        }\n\n        public get id(): string {\n            return this.msgID\n        }\n    }\n\n    export let pendingPromises: Promise<Response>[] = []\n\n    function sendMessage(dest: string, payload: string): void {\n        let msgID = \"msg\" + msgCounter++\n        let packet = `${mySerial}|${dest}|MSG|${msgID}|${payload}`\n        radio.sendString(packet)\n        console.log(`🚀 Sent MSG to ${dest}: ${payload} (ID: ${msgID})`)\n    }\n\n    export function sendPing(dest: string, query: string): Promise<Response> {\n        let msgID = \"ping\" + msgCounter++\n        let packet = `${mySerial}|${dest}|PING|${msgID}|${query}`\n        radio.sendString(packet)\n        console.log(`🔍 Sent PING to ${dest}: ${query} (ID: ${msgID})`)\n\n        let promise = new Promise<Response>(msgID)\n        pendingPromises.push(promise)\n        return promise\n    }\n\n    // 🔘 Example usage\n    let ping = sendPing(\"BCAST\", \"ME\")\n    ping.then(function (response: string) {\n        console.log(`🔧 Ping resolved with: ${response}`)\n    })\n}","aes.ts":"// Add your code here\nnamespace AES {\n    const sbox: number[] = [\n        // A small sample substitution box — extend or randomize as needed!\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76\n    ]\n    function generateInverseSbox(original: number[]): number[] {\n        let inverse = []\n        for (let i = 0; i < 256; i++) inverse.push(0)\n        for (let i = 0; i < original.length; i++) {\n            inverse[original[i]] = i\n        }\n        return inverse\n    }\n\n    const sbox2 = generateInverseSbox(sbox)\n    function subBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function usubBytes(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, sbox2[val % sbox.length]) // Wrap around for simplicity\n        }\n        return output\n    }\n    function shiftRows(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let shiftedIndex = (i + (i % 4)) % buffer.length\n            output.setUint8(i, buffer.getUint8(shiftedIndex))\n        }\n        return output\n    }\n\n    function mixColumns(buffer: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            let val = buffer.getUint8(i)\n            output.setUint8(i, ((val << 1) ^ val ^ 0x1b) & 0xFF) // Basic XOR mix\n        }\n        return output\n    }\n\n    function addRoundKey(buffer: Buffer, key: Buffer): Buffer {\n        let output = control.createBuffer(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n            output.setUint8(i, buffer.getUint8(i) ^ key.getUint8(i % key.length))\n        }\n        return output\n    }\n\n    export function encrypt(input: Buffer, key: Buffer): string {\n        let state = input\n\n        // 📘 AES-like stages\n        state = subBytes(state)\n        state = shiftRows(state)\n        state = mixColumns(state)\n        state = addRoundKey(state, key)\n\n        return state.toBase64()\n    }\n\n    export function decrypt(encoded: string, key: Buffer): Buffer {\n        let state = Buffer.fromBase64(encoded)\n\n        // 🔄 Reverse order for decryption\n        state = addRoundKey(state, key)\n        state = mixColumns(state)\n        state = shiftRows(state)\n        state = usubBytes(state) // reverse S-Box would go here if needed\n\n        return state\n    }\n\n    export function padKey(key32:number) {\n        const buf = Buffer.create(16)\n        \n        for (let i = 0; i < 3; i++) {\n            buf.setNumber(NumberFormat.UInt32LE, i, key32)\n        }\n        return buf;\n    }\n}","dh.ts":"namespace DH {\n    // 🔢 Primes and possible generators (small and demo-safe)\n    const primes = [23, 29, 31, 37, 41, 43, 47]\n    const generators = [2, 3, 5, 7]\n\n    // 🎲 Random prime + generator\n    export const P = 47//primes[Math.randomRange(0, primes.length)]\n    export const G = 5//generators[Math.randomRange(0, generators.length)]\n\n    const mySerial = control.deviceSerialNumber()\n    radio.setGroup(1)\n\n    let sharedKey = -1\n    let privateKey: number\n    export let publicKey: number\n    export let peerSerial = -1\n    export let peerPublicKey = -1\n    export let handshakeCompleted = false\n\n    // 🔑 Generate keys\n    export function generateKeys(): void {\n        privateKey = 2//Math.randomRange(2, P - 2)\n        publicKey = G//Math.pow(G, privateKey) % P\n        console.log(`🔧 DH params: P=${P}, G=${G}, private=${privateKey}, public=${publicKey}`)\n    }\n\n    // 🧮 Compute shared key\n    export function computeSharedKey(peerKey: number): void {\n        sharedKey = Math.pow(peerKey, privateKey) % P\n        handshakeCompleted = true\n        console.log(`🔐 Shared key computed: ${sharedKey}`)\n    }\n\n    // 📡 Send DH data\n    export function broadcastDH(): void {\n        let msgID = \"dh_\" + Math.randomRange(1000, 9999)\n        let packet = `${mySerial}|BCAST|DH|${msgID}|${P},${G},${publicKey}`\n        radio.sendString(packet)\n        console.log(`📤 Sent DH packet`)\n    }\n\n    // 🔁 Retry loop for client broadcast\n    function keepSendingUntilComplete(): void {\n        control.runInParallel(function () {\n            while (!handshakeCompleted) {\n                broadcastDH()\n                pause(500)\n            }\n        })\n    }\n\n    // 🚀 Start handshake\n    export function startHandshake(isServer: boolean): void {\n        generateKeys()\n\n        if (!ISERVER) {\n            keepSendingUntilComplete()\n        }\n    }\n\n    export function getSharedKey(): number {\n        return sharedKey\n    }\n\n    export function isComplete(): boolean {\n        return handshakeCompleted\n    }\n}","wait.ts":"namespace Wait {\n    class Connection {\n        public timestamp: number\n        constructor() {\n            this.timestamp = control.millis()\n        }\n\n        public isFresh(): boolean {\n            return control.millis() - this.timestamp < 10000\n        }\n    }\n\n    class Promise<Connection> {\n        private resolved = false\n        private conn: any = null\n        private resolver: (conn: Connection) => void = null\n        \n        constructor() {}\n\n        public then(res: (conn: Connection) => void): void {\n            this.resolver = res\n            let id = setInterval(function() {\n                if (this.resolved && this.conn) res(this.conn); clearInterval(id)\n            },100)\n        }\n\n        public resolve(): void {\n            if (!this.resolved) {\n                this.conn = new Connection()\n                this.resolved = true\n                if (this.resolver) this.resolver(this.conn)\n            }\n        }\n    }\n\n    export let pending: Promise<Connection>[] = []\n\n    export function waitForReady(): Promise<Connection> {\n        let promise = new Promise<Connection>()\n        pending.push(promise)\n\n        // Broadcast our readiness so others can respond\n        let msgID = \"ready\" + Math.randomRange(1000, 9999)\n        radio.sendString(`READY|${msgID}`)\n        console.log(\"📡 Broadcasted readiness\")\n\n        return promise\n    }\n}","simplekeyexhange.ts":"namespace SharedKey {\n    export let _key = -1\n    let mySerial = control.deviceSerialNumber()\n    let initialized = false\n\n    export function broadcastKey(globalKey?: number): void {\n        if (isSet()) return\n        _key = globalKey || ((randint(0, 255) << 24) | (randint(0, 255) << 16) | (randint(0, 255) << 8) | randint(0, 255))\n        console.log(`🔐 32-bit key generated: ${_key}`)\n        radio.sendString(`SHAREDKEY|${_key}`)\n        pause(5)\n        radio.sendString(`SHAREDKEY|${_key}`)\n        console.log(`📡 Shared key broadcast: ${_key}`)\n    }\n\n    export function isSet(): boolean {\n        return _key != -1\n    }\n\n    export function getKey(): number {\n        return _key\n    }\n}","pxt.json":"{\n    \"name\": \"ECP\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"radio-broadcast\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"server.ts\",\n        \"client.ts\",\n        \"aes.ts\",\n        \"dh.ts\",\n        \"wait.ts\",\n        \"simplekeyexhange.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1752789110009}